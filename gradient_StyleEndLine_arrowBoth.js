// Generated by Haxe 4.3.0-rc.1+5f599ba
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var cornerContour_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.pen = pen_;
	this.endLine = endLine_;
};
cornerContour_Contour.__name__ = true;
cornerContour_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = theta0;
			var fb = theta1;
			var theta = Math.abs(theta0 - theta1);
			var smallest = theta <= Math.PI;
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3 || this.endLine == 6 || this.endLine == 8 || this.endLine == 9 || this.endLine == 11)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			this.pieXs(ax,ay,width_ / 2,beta,gamma,fracs_DifferencePreference.SMALL_OLD,temp,-1,36);
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(this.count == 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var temp = [];
			this.pieXs(ax,ay,width_ / 2,beta,gamma,fracs_DifferencePreference.SMALL_OLD,temp,-1,36);
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,-1);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,-1);
				} else {
					this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,-1);
				}
			} else if(clockWise) {
				this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				this.pen.triangle2DFill(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0 && (this.endLine == 2 || this.endLine == 3 || this.endLine == 7 || this.endLine == 8 || this.endLine == 11 || this.endLine == 10)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			if(!(this.endLine == 8 || this.endLine == 11 || this.endLine == 7 || this.endLine == 10)) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var arrowFactor = 1.45;
					var dx = ax1 - radius * arrowFactor * Math.sin(angle);
					var dy = ay1 - radius * arrowFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * arrowFactor * Math.sin(angle);
					cy = ay1 - radius * arrowFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(dx,dy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * arrowFactor * Math.sin(angle);
					cy = ay1 + radius * arrowFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					angle = beta;
					var dx = ax1 - radius * Math.sin(angle);
					var dy = ay1 - radius * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * Math.sin(angle);
					cy = ay1 - radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(dx,dy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
		if(this.count != 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var temp = [];
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			if(!(this.endLine == 8 || this.endLine == 11 || this.endLine == 7 || this.endLine == 10)) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var arrowFactor = 1.45;
					var dx = ax1 - radius * arrowFactor * Math.sin(angle);
					var dy = ay1 - radius * arrowFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * arrowFactor * Math.sin(angle);
					cy = ay1 - radius * arrowFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(dx,dy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * arrowFactor * Math.sin(angle);
					cy = ay1 + radius * arrowFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					angle = beta;
					var dx = ax1 - radius * Math.sin(angle);
					var dy = ay1 - radius * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * Math.sin(angle);
					cy = ay1 - radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(dx,dy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld,-1);
			}
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy,-1);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld,-1);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy,-1);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 4:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 5:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 6:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 7:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 8:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 9:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 10:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 11:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,-1);
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,-1);
	}
	,pieXs: function(ax,ay,radius,beta,gamma,prefer,edgePoly,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		if(!(this.endLine == 8 || this.endLine == 6 || this.endLine == 11 || this.endLine == 9)) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax += radius * Math.sin(angle2);
				ay += radius * Math.cos(angle2);
				radius *= 2;
			}
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				edgePoly[p2++] = cx;
				edgePoly[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax + radius * Math.sin(angle) * Math.sqrt(2);
				cy = ay + radius * Math.cos(angle) * Math.sqrt(2);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				totalSteps += 2;
			}
		} else {
			if(this.endLine == 11 || this.endLine == 9) {
				angle = beta;
				var arrowFactor = 1.45;
				var dx = ax - radius * arrowFactor * Math.sin(angle);
				var dy = ay - radius * arrowFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax - radius * arrowFactor * Math.sin(angle);
				cy = ay - radius * arrowFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(dx,dy,cx,cy,ax,ay,color_);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax + radius * arrowFactor * Math.sin(angle);
				cy = ay + radius * arrowFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			} else {
				angle = beta;
				var dx = ax - radius * Math.sin(angle);
				var dy = ay - radius * Math.cos(angle);
				angle = beta + step * totalSteps / 2;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(dx,dy,cx,cy,ax,ay,color_);
				bx = cx;
				by = cy;
				angle -= step * totalSteps / 2;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			}
			totalSteps += 2;
		}
		return totalSteps;
	}
};
var cornerContour_ContourGrad = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.colorGradChoice = "colorAB";
	this.pen = pen_;
	this.endLine = endLine_;
};
cornerContour_ContourGrad.__name__ = true;
cornerContour_ContourGrad.prototype = {
	getGradColors: function() {
		switch(this.colorGradChoice) {
		case "colorAB":
			return new cornerContour_color_TwoGrad_$(this.pen.currentColor,this.pen.colorB);
		case "colorAC":
			return new cornerContour_color_TwoGrad_$(this.pen.currentColor,this.pen.colorC);
		case "colorBA":
			return new cornerContour_color_TwoGrad_$(this.pen.colorB,this.pen.currentColor);
		case "colorBC":
			return new cornerContour_color_TwoGrad_$(this.pen.colorB,this.pen.colorC);
		case "colorCA":
			return new cornerContour_color_TwoGrad_$(this.pen.colorC,this.pen.currentColor);
		case "colorCB":
			return new cornerContour_color_TwoGrad_$(this.pen.colorC,this.pen.colorB);
		}
	}
	,reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = theta0;
			var fb = theta1;
			var theta = Math.abs(theta0 - theta1);
			var smallest = theta <= Math.PI;
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3 || this.endLine == 6 || this.endLine == 8 || this.endLine == 11 || this.endLine == 9)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var clockwiseTemp = false;
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif1) / (step / 2)) : Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx = 0;
			var cy = 0;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var col = this.getGradColors();
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			if(!(this.endLine == 8 || this.endLine == 6 || this.endLine == 11 || this.endLine == 9)) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				if(this.endLine == 5) {
					half = col.colorAnti;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						if(!clockwiseTemp) {
							var second;
							if(this.endLine == 4) {
								var c0 = col.colorAnti;
								var c1 = col.colorClock;
								var t = 0.5 * i / totalSteps;
								if(t == null) {
									t = 0.5;
								}
								var t0 = t;
								if(t0 == null) {
									t0 = 0.5;
								}
								var t1 = 1. - t0;
								var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
								var t01 = t;
								if(t01 == null) {
									t01 = 0.5;
								}
								var t11 = 1. - t01;
								var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
								var t02 = t;
								if(t02 == null) {
									t02 = 0.5;
								}
								var t12 = 1. - t02;
								var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
								var t03 = t;
								if(t03 == null) {
									t03 = 0.5;
								}
								var t13 = 1. - t03;
								var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
								second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							} else {
								var c01 = col.colorAnti;
								var c11 = col.colorClock;
								var t2 = i / totalSteps;
								if(t2 == null) {
									t2 = 0.5;
								}
								var t04 = t2;
								if(t04 == null) {
									t04 = 0.5;
								}
								var t14 = 1. - t04;
								var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
								var t05 = t2;
								if(t05 == null) {
									t05 = 0.5;
								}
								var t15 = 1. - t05;
								var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
								var t06 = t2;
								if(t06 == null) {
									t06 = 0.5;
								}
								var t16 = 1. - t06;
								var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
								var t07 = t2;
								if(t07 == null) {
									t07 = 0.5;
								}
								var t17 = 1. - t07;
								var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
								second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
						} else {
							var c02 = col.colorAnti;
							var c12 = col.colorClock;
							var t3 = 1 - i / totalSteps;
							if(t3 == null) {
								t3 = 0.5;
							}
							var t08 = t3;
							if(t08 == null) {
								t08 = 0.5;
							}
							var t18 = 1. - t08;
							var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
							var t09 = t3;
							if(t09 == null) {
								t09 = 0.5;
							}
							var t19 = 1. - t09;
							var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
							var t010 = t3;
							if(t010 == null) {
								t010 = 0.5;
							}
							var t110 = 1. - t010;
							var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
							var t011 = t3;
							if(t011 == null) {
								t011 = 0.5;
							}
							var t111 = 1. - t011;
							var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
							var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,half,col.colorAnti);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 9) {
					angle = beta;
					var arrowFactor = 1.45;
					var dx = ax1 - radius * arrowFactor * Math.sin(angle);
					var dy = ay1 - radius * arrowFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * arrowFactor * Math.sin(angle);
					cy = ay1 - radius * arrowFactor * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * arrowFactor * Math.sin(angle);
					cy = ay1 + radius * arrowFactor * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
				} else {
					angle = beta;
					var dx = ax1 - radius * Math.sin(angle);
					var dy = ay1 - radius * Math.cos(angle);
					angle = beta + step * totalSteps / 2;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle -= step * totalSteps / 2;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(this.count == 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var temp = [];
			var clockwiseTemp = false;
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif1) / (step / 2)) : Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx = 0;
			var cy = 0;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var col = this.getGradColors();
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			if(!(this.endLine == 8 || this.endLine == 6 || this.endLine == 11 || this.endLine == 9)) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				if(this.endLine == 5) {
					half = col.colorAnti;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						if(!clockwiseTemp) {
							var second;
							if(this.endLine == 4) {
								var c0 = col.colorAnti;
								var c1 = col.colorClock;
								var t = 0.5 * i / totalSteps;
								if(t == null) {
									t = 0.5;
								}
								var t0 = t;
								if(t0 == null) {
									t0 = 0.5;
								}
								var t1 = 1. - t0;
								var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
								var t01 = t;
								if(t01 == null) {
									t01 = 0.5;
								}
								var t11 = 1. - t01;
								var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
								var t02 = t;
								if(t02 == null) {
									t02 = 0.5;
								}
								var t12 = 1. - t02;
								var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
								var t03 = t;
								if(t03 == null) {
									t03 = 0.5;
								}
								var t13 = 1. - t03;
								var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
								second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							} else {
								var c01 = col.colorAnti;
								var c11 = col.colorClock;
								var t2 = i / totalSteps;
								if(t2 == null) {
									t2 = 0.5;
								}
								var t04 = t2;
								if(t04 == null) {
									t04 = 0.5;
								}
								var t14 = 1. - t04;
								var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
								var t05 = t2;
								if(t05 == null) {
									t05 = 0.5;
								}
								var t15 = 1. - t05;
								var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
								var t06 = t2;
								if(t06 == null) {
									t06 = 0.5;
								}
								var t16 = 1. - t06;
								var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
								var t07 = t2;
								if(t07 == null) {
									t07 = 0.5;
								}
								var t17 = 1. - t07;
								var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
								second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
						} else {
							var c02 = col.colorAnti;
							var c12 = col.colorClock;
							var t3 = 1 - i / totalSteps;
							if(t3 == null) {
								t3 = 0.5;
							}
							var t08 = t3;
							if(t08 == null) {
								t08 = 0.5;
							}
							var t18 = 1. - t08;
							var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
							var t09 = t3;
							if(t09 == null) {
								t09 = 0.5;
							}
							var t19 = 1. - t09;
							var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
							var t010 = t3;
							if(t010 == null) {
								t010 = 0.5;
							}
							var t110 = 1. - t010;
							var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
							var t011 = t3;
							if(t011 == null) {
								t011 = 0.5;
							}
							var t111 = 1. - t011;
							var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
							var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,half,col.colorAnti);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 9) {
					angle = beta;
					var arrowFactor = 1.45;
					var dx = ax1 - radius * arrowFactor * Math.sin(angle);
					var dy = ay1 - radius * arrowFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * arrowFactor * Math.sin(angle);
					cy = ay1 - radius * arrowFactor * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * arrowFactor * Math.sin(angle);
					cy = ay1 + radius * arrowFactor * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
				} else {
					angle = beta;
					var dx = ax1 - radius * Math.sin(angle);
					var dy = ay1 - radius * Math.cos(angle);
					angle = beta + step * totalSteps / 2;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle -= step * totalSteps / 2;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,col.colorClock,half);
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var ax_1 = this.dxPrev;
			var ay_1 = this.dyPrev;
			var bx_ = this.dx;
			var by_ = this.dy;
			var cx_ = this.ex;
			var cy_ = this.ey;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
			var ax_1 = this.dxPrev;
			var ay_1 = this.dyPrev;
			var bx_ = this.dx;
			var by_ = this.dy;
			var cx_ = this.exPrev;
			var cy_ = this.eyPrev;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var ax_1 = this.dxPrev;
				var ay_1 = this.dyPrev;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.ex;
				var cy_ = this.ey;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
				var ax_1 = this.jx;
				var ay_1 = this.jy;
				var bx_ = this.dx;
				var by_ = this.dy;
				var cx_ = this.exPrev;
				var cy_ = this.eyPrev;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,A);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.exPrev;
					var cy_ = this.eyPrev;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,A);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.exPrev;
					var cy_ = this.eyPrev;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,A);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					var ax_1 = this.dxPrev;
					var ay_1 = this.dyPrev;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.jx;
					var cy_ = this.jy;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,A);
					var ax_1 = this.dxPrev;
					var ay_1 = this.dyPrev;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					var ax_1 = this.jx;
					var ay_1 = this.jy;
					var bx_ = this.dx;
					var by_ = this.dy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,A,A,C);
					var ax_1 = this.dxPrev;
					var ay_1 = this.dyPrev;
					var bx_ = this.jx;
					var by_ = this.jy;
					var cx_ = this.ex;
					var cy_ = this.ey;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_1,ay_1,bx_,by_,cx_,cy_,C,A,C);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						if(!clockWise) {
							var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
							var c0 = col.colorAnti;
							var c1 = col.colorClock;
							var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
							var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
							var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
							var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
							var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,half,col.colorClock,col.colorClock);
						} else {
							var col1 = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
							var c01 = col1.colorAnti;
							var c11 = col1.colorClock;
							var a1 = ((c01 >> 24 & 255) / 255 + (c11 >> 24 & 255) / 255) / 2;
							var r1 = ((c01 >> 16 & 255) / 255 + (c11 >> 16 & 255) / 255) / 2;
							var g1 = ((c01 >> 8 & 255) / 255 + (c11 >> 8 & 255) / 255) / 2;
							var b1 = ((c01 & 255) / 255 + (c11 & 255) / 255) / 2;
							var half1 = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,half1,col1.colorAnti,col1.colorAnti);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						if(!clockWise) {
							var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
							var c0 = col.colorAnti;
							var c1 = col.colorClock;
							var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
							var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
							var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
							var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
							var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,half,col.colorClock,col.colorClock);
						} else {
							var col1 = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
							var c01 = col1.colorAnti;
							var c11 = col1.colorClock;
							var a1 = ((c01 >> 24 & 255) / 255 + (c11 >> 24 & 255) / 255) / 2;
							var r1 = ((c01 >> 16 & 255) / 255 + (c11 >> 16 & 255) / 255) / 2;
							var g1 = ((c01 >> 8 & 255) / 255 + (c11 >> 8 & 255) / 255) / 2;
							var b1 = ((c01 & 255) / 255 + (c11 & 255) / 255) / 2;
							var half1 = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,half1,col1.colorAnti,col1.colorAnti);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var ax_ = this.dxOld;
					var ay_ = this.dyOld;
					var bx_ = this.exPrev;
					var by_ = this.eyPrev;
					var cx_ = this.ax;
					var cy_ = this.ay;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,A,C);
				} else {
					var ax_ = this.exOld;
					var ay_ = this.eyOld;
					var bx_ = this.dxPrev;
					var by_ = this.dyPrev;
					var cx_ = this.ax;
					var cy_ = this.ay;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var C = col.colorClock;
					var A = col.colorAnti;
					this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				}
			} else if(clockWise) {
				var ax_ = this.dxOld;
				var ay_ = this.dyOld;
				var bx_ = this.exPrev;
				var by_ = this.eyPrev;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,A,A,C);
			} else {
				var ax_ = this.exOld;
				var ay_ = this.eyOld;
				var bx_ = this.dxPrev;
				var by_ = this.dyPrev;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				var ax_ = this.ax;
				var ay_ = this.ay;
				var bx_ = this.dxOld;
				var by_ = this.dyOld;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var c0 = col.colorAnti;
				var c1 = col.colorClock;
				var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
				var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
				var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
				var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
				var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorClock,col.colorAnti);
				var ax_ = this.ax;
				var ay_ = this.ay;
				var bx_ = this.exPrev;
				var by_ = this.eyPrev;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var c0 = col.colorAnti;
				var c1 = col.colorClock;
				var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
				var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
				var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
				var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
				var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorAnti,col.colorClock);
			} else {
				var ax_ = this.ax;
				var ay_ = this.ay;
				var bx_ = this.exOld;
				var by_ = this.eyOld;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var c0 = col.colorAnti;
				var c1 = col.colorClock;
				var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
				var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
				var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
				var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
				var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorClock,col.colorAnti);
				var ax_ = this.ax;
				var ay_ = this.ay;
				var bx_ = this.dxPrev;
				var by_ = this.dyPrev;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var c0 = col.colorAnti;
				var c1 = col.colorClock;
				var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
				var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
				var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
				var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
				var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,half,col.colorAnti,col.colorClock);
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0 && (this.endLine == 2 || this.endLine == 3 || this.endLine == 7 || this.endLine == 8 || this.endLine == 11 || this.endLine == 10)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var clockwiseTemp = false;
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif) / (step / 2)) : Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var col = this.getGradColors();
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			if(!(this.endLine == 8 || this.endLine == 11 || this.endLine == 7 || this.endLine == 10)) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				if(this.endLine == 5) {
					half = col.colorAnti;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						if(!clockwiseTemp) {
							var second;
							if(this.endLine == 4) {
								var c0 = col.colorAnti;
								var c1 = col.colorClock;
								var t = 0.5 * i / totalSteps;
								if(t == null) {
									t = 0.5;
								}
								var t0 = t;
								if(t0 == null) {
									t0 = 0.5;
								}
								var t1 = 1. - t0;
								var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
								var t01 = t;
								if(t01 == null) {
									t01 = 0.5;
								}
								var t11 = 1. - t01;
								var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
								var t02 = t;
								if(t02 == null) {
									t02 = 0.5;
								}
								var t12 = 1. - t02;
								var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
								var t03 = t;
								if(t03 == null) {
									t03 = 0.5;
								}
								var t13 = 1. - t03;
								var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
								second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							} else {
								var c01 = col.colorAnti;
								var c11 = col.colorClock;
								var t2 = i / totalSteps;
								if(t2 == null) {
									t2 = 0.5;
								}
								var t04 = t2;
								if(t04 == null) {
									t04 = 0.5;
								}
								var t14 = 1. - t04;
								var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
								var t05 = t2;
								if(t05 == null) {
									t05 = 0.5;
								}
								var t15 = 1. - t05;
								var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
								var t06 = t2;
								if(t06 == null) {
									t06 = 0.5;
								}
								var t16 = 1. - t06;
								var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
								var t07 = t2;
								if(t07 == null) {
									t07 = 0.5;
								}
								var t17 = 1. - t07;
								var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
								second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
						} else {
							var c02 = col.colorAnti;
							var c12 = col.colorClock;
							var t3 = 1 - i / totalSteps;
							if(t3 == null) {
								t3 = 0.5;
							}
							var t08 = t3;
							if(t08 == null) {
								t08 = 0.5;
							}
							var t18 = 1. - t08;
							var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
							var t09 = t3;
							if(t09 == null) {
								t09 = 0.5;
							}
							var t19 = 1. - t09;
							var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
							var t010 = t3;
							if(t010 == null) {
								t010 = 0.5;
							}
							var t110 = 1. - t010;
							var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
							var t011 = t3;
							if(t011 == null) {
								t011 = 0.5;
							}
							var t111 = 1. - t011;
							var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
							var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,half);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var arrowFactor = 1.45;
					var dx = ax1 - radius * arrowFactor * Math.sin(angle);
					var dy = ay1 - radius * arrowFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * arrowFactor * Math.sin(angle);
					cy = ay1 - radius * arrowFactor * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * arrowFactor * Math.sin(angle);
					cy = ay1 + radius * arrowFactor * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
				} else {
					angle = beta;
					var dx = ax1 - radius * Math.sin(angle);
					var dy = ay1 - radius * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * Math.sin(angle);
					cy = ay1 - radius * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
		if(this.count != 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var temp = [];
			var clockwiseTemp = false;
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = this.endLine == 5 ? Math.ceil(Math.abs(dif) / (step / 2)) : Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var col = this.getGradColors();
			var c0 = col.colorAnti;
			var c1 = col.colorClock;
			var a = ((c0 >> 24 & 255) / 255 + (c1 >> 24 & 255) / 255) / 2;
			var r = ((c0 >> 16 & 255) / 255 + (c1 >> 16 & 255) / 255) / 2;
			var g = ((c0 >> 8 & 255) / 255 + (c1 >> 8 & 255) / 255) / 2;
			var b = ((c0 & 255) / 255 + (c1 & 255) / 255) / 2;
			var half = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			var dx = ax1 + radius * Math.sin(angle);
			var dy = ay1 + radius * Math.cos(angle);
			if(!(this.endLine == 8 || this.endLine == 11 || this.endLine == 7 || this.endLine == 10)) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				if(this.endLine == 5) {
					half = col.colorAnti;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						if(!clockwiseTemp) {
							var second;
							if(this.endLine == 4) {
								var c0 = col.colorAnti;
								var c1 = col.colorClock;
								var t = 0.5 * i / totalSteps;
								if(t == null) {
									t = 0.5;
								}
								var t0 = t;
								if(t0 == null) {
									t0 = 0.5;
								}
								var t1 = 1. - t0;
								var a = t0 * ((c0 >> 24 & 255) / 255) + t1 * ((c1 >> 24 & 255) / 255);
								var t01 = t;
								if(t01 == null) {
									t01 = 0.5;
								}
								var t11 = 1. - t01;
								var r = t01 * ((c0 >> 16 & 255) / 255) + t11 * ((c1 >> 16 & 255) / 255);
								var t02 = t;
								if(t02 == null) {
									t02 = 0.5;
								}
								var t12 = 1. - t02;
								var g = t02 * ((c0 >> 8 & 255) / 255) + t12 * ((c1 >> 8 & 255) / 255);
								var t03 = t;
								if(t03 == null) {
									t03 = 0.5;
								}
								var t13 = 1. - t03;
								var b = t03 * ((c0 & 255) / 255) + t13 * ((c1 & 255) / 255);
								second = Math.round(a * 255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
							} else {
								var c01 = col.colorAnti;
								var c11 = col.colorClock;
								var t2 = i / totalSteps;
								if(t2 == null) {
									t2 = 0.5;
								}
								var t04 = t2;
								if(t04 == null) {
									t04 = 0.5;
								}
								var t14 = 1. - t04;
								var a1 = t04 * ((c01 >> 24 & 255) / 255) + t14 * ((c11 >> 24 & 255) / 255);
								var t05 = t2;
								if(t05 == null) {
									t05 = 0.5;
								}
								var t15 = 1. - t05;
								var r1 = t05 * ((c01 >> 16 & 255) / 255) + t15 * ((c11 >> 16 & 255) / 255);
								var t06 = t2;
								if(t06 == null) {
									t06 = 0.5;
								}
								var t16 = 1. - t06;
								var g1 = t06 * ((c01 >> 8 & 255) / 255) + t16 * ((c11 >> 8 & 255) / 255);
								var t07 = t2;
								if(t07 == null) {
									t07 = 0.5;
								}
								var t17 = 1. - t07;
								var b1 = t07 * ((c01 & 255) / 255) + t17 * ((c11 & 255) / 255);
								second = Math.round(a1 * 255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
							}
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second,second);
						} else {
							var c02 = col.colorAnti;
							var c12 = col.colorClock;
							var t3 = 1 - i / totalSteps;
							if(t3 == null) {
								t3 = 0.5;
							}
							var t08 = t3;
							if(t08 == null) {
								t08 = 0.5;
							}
							var t18 = 1. - t08;
							var a2 = t08 * ((c02 >> 24 & 255) / 255) + t18 * ((c12 >> 24 & 255) / 255);
							var t09 = t3;
							if(t09 == null) {
								t09 = 0.5;
							}
							var t19 = 1. - t09;
							var r2 = t09 * ((c02 >> 16 & 255) / 255) + t19 * ((c12 >> 16 & 255) / 255);
							var t010 = t3;
							if(t010 == null) {
								t010 = 0.5;
							}
							var t110 = 1. - t010;
							var g2 = t010 * ((c02 >> 8 & 255) / 255) + t110 * ((c12 >> 8 & 255) / 255);
							var t011 = t3;
							if(t011 == null) {
								t011 = 0.5;
							}
							var t111 = 1. - t011;
							var b2 = t011 * ((c02 & 255) / 255) + t111 * ((c12 & 255) / 255);
							var second1 = Math.round(a2 * 255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
							this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,second1,second1);
						}
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,half);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,cx,cy,bx,by,half,col.colorAnti,col.colorAnti);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var arrowFactor = 1.45;
					var dx = ax1 - radius * arrowFactor * Math.sin(angle);
					var dy = ay1 - radius * arrowFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * arrowFactor * Math.sin(angle);
					cy = ay1 - radius * arrowFactor * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * arrowFactor * Math.sin(angle);
					cy = ay1 + radius * arrowFactor * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
				} else {
					angle = beta;
					var dx = ax1 - radius * Math.sin(angle);
					var dy = ay1 - radius * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * Math.sin(angle);
					cy = ay1 - radius * Math.cos(angle);
					this.pen.triangle2DGrad(dx,dy,cx,cy,ax1,ay1,col.colorAnti,half,half);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					this.pen.triangle2DGrad(ax1,ay1,bx,by,cx,cy,half,half,col.colorClock);
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
			this.pen.set_pos(this.quadIndex);
			var ax_ = this.kax;
			var ay_ = this.kay;
			var bx_ = this.kbx;
			var by_ = this.kby;
			var cx_ = this.jx;
			var cy_ = this.jy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				var ax_ = this.jxOld;
				var ay_ = this.jyOld;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.jx;
				var cy_ = this.jy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.jxOld;
				var ay_ = this.jyOld;
				var bx_ = this.kbx;
				var by_ = this.kby;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			var ax_ = this.kax;
			var ay_ = this.kay;
			var bx_ = this.jx;
			var by_ = this.jy;
			var cx_ = this.kcx;
			var cy_ = this.kcy;
			var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
			var C = col.colorClock;
			var A = col.colorAnti;
			this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.jxOld;
				var cy_ = this.jyOld;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.kcx;
				var cy_ = this.kcy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.kax;
				var ay_ = this.kay;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				var ax_ = this.jxOld;
				var ay_ = this.jyOld;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.kcx;
				var cy_ = this.kcy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,C);
				this.pen.set_pos(this.quadIndex + 1);
				var ax_ = this.jxOld;
				var ay_ = this.jyOld;
				var bx_ = this.jx;
				var by_ = this.jy;
				var cx_ = this.ncx;
				var cy_ = this.ncy;
				var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
				var C = col.colorClock;
				var A = col.colorAnti;
				this.pen.triangle2DGrad(ax_,ay_,bx_,by_,cx_,cy_,C,A,A);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 4:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 5:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 6:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 7:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 8:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 9:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 10:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 11:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(ax_,ay_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
					var red = -65536;
					var blue = -16711936;
					var green = -16776961;
					this.pen.triangle2DGrad(bx_,by_,bx,by,cx,cy,red,green,blue);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		var bx_ = this.dx;
		var by_ = this.dy;
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(dxPrev_,dyPrev_,bx_,by_,exPrev_,eyPrev_,A,C,C);
		var bx_ = this.dx;
		var by_ = this.dy;
		var cx_ = this.ex;
		var cy_ = this.ey;
		var col = this.twoGrad == null ? this.getGradColors() : this.twoGrad;
		var C = col.colorClock;
		var A = col.colorAnti;
		this.pen.triangle2DGrad(dxPrev_,dyPrev_,bx_,by_,cx_,cy_,A,C,A);
	}
};
var cornerContour_Pen2DGrad = function(col,colB,colC) {
	var this1 = [];
	this1[0] = 0.;
	this.arr = this1;
	haxe_Log.trace("Pen2DGrad ",{ fileName : "cornerContour/Pen2DGrad.hx", lineNumber : 14, className : "cornerContour.Pen2DGrad", methodName : "new"});
	this.currentColor = col;
	haxe_Log.trace(" arr " + Std.string(this.arr),{ fileName : "cornerContour/Pen2DGrad.hx", lineNumber : 16, className : "cornerContour.Pen2DGrad", methodName : "new"});
	var hasB = colB == null;
	var hasC = colC == null;
	if(!hasB) {
		colB = col;
	}
	this.colorB = colB;
	if(!hasC) {
		colC = col;
	}
	this.colorC = colC;
};
cornerContour_Pen2DGrad.__name__ = true;
cornerContour_Pen2DGrad.prototype = {
	get_pos: function() {
		return this.arr[0];
	}
	,set_pos: function(val) {
		this.arr[0] = val;
		return val;
	}
	,triangle2DFill: function(ax,ay,bx,by,cx,cy,color) {
		if(color == null || color == -1) {
			color = this.currentColor;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriGrad.triangle(this1,ax,ay,bx,by,cx,cy);
		if(color == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntA(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntA(this1,color);
		}
		if(color == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntB(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntB(this1,color);
		}
		if(color == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntC(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntC(this1,color);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
	,triangle2DGrad: function(ax,ay,bx,by,cx,cy,colorA,colorB,colorC) {
		if(colorA == null || colorA == -1) {
			colorA = this.currentColor;
		}
		if(colorB == null || colorB == -1) {
			colorB = this.colorB;
		}
		if(colorC == null || colorC == -1) {
			colorC = this.colorC;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriGrad.triangle(this1,ax,ay,bx,by,cx,cy);
		if(colorA == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntA(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntA(this1,colorA);
		}
		if(colorB == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntB(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntB(this1,colorB);
		}
		if(colorC == null) {
			cornerContour_io_Array2DTriGrad.set_colorIntC(this1,16711680);
		} else {
			cornerContour_io_Array2DTriGrad.set_colorIntC(this1,colorC);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
};
var cornerContour_Sketcher = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.historyParameters = [];
	this.historyCommands = [];
	this.historyParamPos = [];
	this.turtleParameters = [];
	this.turtleCommands = [];
	this.repeatCommands = false;
	this.fill = false;
	this.lastDistance = 0.;
	this.rotation = 0.;
	this.penIsDown = true;
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.rotation = -Math.PI / 2;
	this.pen = pen_;
	this.endLine = endLine_;
	this.contour = this.createContour();
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
cornerContour_Sketcher.__name__ = true;
cornerContour_Sketcher.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 30, className : "cornerContour.Sketcher", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 30, className : "cornerContour.Sketcher", methodName : "tracerLine"});
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,crudeLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,roundEndLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width,3);
	}
	,mediumLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false);
	}
	,mediumOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false,true);
	}
	,fineLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true);
	}
	,fineOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true,true);
	}
	,createContour: function() {
		return new cornerContour_Contour(this.pen,this.endLine);
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
	,historyAdd: function(command) {
		this.historyParamPos.push(this.historyParameters.length);
		this.historyCommands.push(command);
		return this.historyParameters.length;
	}
};
var cornerContour_SketcherGrad = function(pen_,sketchForm_,endLine_) {
	cornerContour_Sketcher.call(this,pen_,sketchForm_,endLine_);
};
cornerContour_SketcherGrad.__name__ = true;
cornerContour_SketcherGrad.__super__ = cornerContour_Sketcher;
cornerContour_SketcherGrad.prototype = $extend(cornerContour_Sketcher.prototype,{
	createContour: function() {
		return new cornerContour_ContourGrad(this.pen,this.endLine);
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			if(this.colourFunctionB != null) {
				this.pen.colorB = this.colourFunctionB(this.pen.colorB,this.x,this.y,x_,y_);
			}
			if(this.colourFunctionC != null) {
				this.pen.colorC = this.colourFunctionC(this.pen.colorC,this.x,this.y,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
});
var cornerContour_color_TwoGrad_$ = function(colorClock,colorAnti) {
	this.colorClock = colorClock;
	this.colorAnti = colorAnti;
};
cornerContour_color_TwoGrad_$.__name__ = true;
var cornerContour_io_Array2DTriGrad = {};
cornerContour_io_Array2DTriGrad.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 9 + 1];
};
cornerContour_io_Array2DTriGrad.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 9 + 1 + 1];
};
cornerContour_io_Array2DTriGrad.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 1 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 9 + 2 + 1];
};
cornerContour_io_Array2DTriGrad.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 2 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_by = function(this1) {
	return this1[(this1[0] | 0) * 9 + 3 + 1];
};
cornerContour_io_Array2DTriGrad.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 3 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 9 + 4 + 1];
};
cornerContour_io_Array2DTriGrad.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 4 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 9 + 5 + 1];
};
cornerContour_io_Array2DTriGrad.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 9 + 5 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorA = function(this1) {
	return this1[(this1[0] | 0) * 9 + 6 + 1];
};
cornerContour_io_Array2DTriGrad.set_colorIntA = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 9 + 6 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorB = function(this1) {
	return this1[(this1[0] | 0) * 9 + 7 + 1];
};
cornerContour_io_Array2DTriGrad.set_colorIntB = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 9 + 7 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriGrad.get_colorC = function(this1) {
	return this1[(this1[0] | 0) * 9 + 8 + 1];
};
cornerContour_io_Array2DTriGrad.set_colorIntC = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 9 + 8 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriGrad.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_Array2DTriGrad.set_ax(this1,ax_);
	cornerContour_io_Array2DTriGrad.set_ay(this1,ay_);
	cornerContour_io_Array2DTriGrad.set_bx(this1,bx_);
	cornerContour_io_Array2DTriGrad.set_by(this1,by_);
	cornerContour_io_Array2DTriGrad.set_cx(this1,cx_);
	cornerContour_io_Array2DTriGrad.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_Array2DTriGrad.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_Array2DTriGrad.set_ax(this1,ax_);
		cornerContour_io_Array2DTriGrad.set_ay(this1,ay_);
		cornerContour_io_Array2DTriGrad.set_bx(this1,cx_);
		cornerContour_io_Array2DTriGrad.set_by(this1,cy_);
		cornerContour_io_Array2DTriGrad.set_cx(this1,bx_);
		cornerContour_io_Array2DTriGrad.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_Array2DTriGrad.adjustWinding = function(this1) {
	return cornerContour_io_Array2DTriGrad.get_ax(this1) * cornerContour_io_Array2DTriGrad.get_by(this1) - cornerContour_io_Array2DTriGrad.get_bx(this1) * cornerContour_io_Array2DTriGrad.get_ay(this1) + (cornerContour_io_Array2DTriGrad.get_bx(this1) * cornerContour_io_Array2DTriGrad.get_cy(this1) - cornerContour_io_Array2DTriGrad.get_cx(this1) * cornerContour_io_Array2DTriGrad.get_by(this1)) + (cornerContour_io_Array2DTriGrad.get_cx(this1) * cornerContour_io_Array2DTriGrad.get_ay(this1) - cornerContour_io_Array2DTriGrad.get_ax(this1) * cornerContour_io_Array2DTriGrad.get_cy(this1)) > 0;
};
var cornerContour_io_Array2DTriangles = {};
cornerContour_io_Array2DTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1];
};
cornerContour_io_Array2DTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1 + 1];
};
cornerContour_io_Array2DTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 2 + 1];
};
cornerContour_io_Array2DTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 2 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 7 + 3 + 1];
};
cornerContour_io_Array2DTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 3 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 4 + 1];
};
cornerContour_io_Array2DTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 4 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 7 + 5 + 1];
};
cornerContour_io_Array2DTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 5 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
	cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
	cornerContour_io_Array2DTriangles.set_bx(this1,bx_);
	cornerContour_io_Array2DTriangles.set_by(this1,by_);
	cornerContour_io_Array2DTriangles.set_cx(this1,cx_);
	cornerContour_io_Array2DTriangles.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_Array2DTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
		cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
		cornerContour_io_Array2DTriangles.set_bx(this1,cx_);
		cornerContour_io_Array2DTriangles.set_by(this1,cy_);
		cornerContour_io_Array2DTriangles.set_cx(this1,bx_);
		cornerContour_io_Array2DTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_Array2DTriangles.adjustWinding = function(this1) {
	return cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_by(this1) - cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) + (cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_cy(this1) - cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_by(this1)) + (cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) - cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_cy(this1)) > 0;
};
var cornerContourWebGLTest_CornerContourWebGL = function() {
	this.vertexColor = "vertexColor";
	this.vertexPosition = "vertexPosition";
	this.styleEnd = 11;
	this.divertTrace = new cornerContourWebGLTest_DivertTrace();
	haxe_Log.trace("Contour Test",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL.js.hx", lineNumber : 113, className : "cornerContourWebGLTest.CornerContourWebGL", methodName : "new"});
	this.width = 1024;
	this.height = 768;
	this.drawContours();
	this.rearrageDrawData();
	this.renderOnce();
};
cornerContourWebGLTest_CornerContourWebGL.__name__ = true;
cornerContourWebGLTest_CornerContourWebGL.prototype = {
	rearrageDrawData: function() {
		haxe_Log.trace("rearrangeDrawData",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL.js.hx", lineNumber : 124, className : "cornerContourWebGLTest.CornerContourWebGL", methodName : "rearrageDrawData"});
		var pen = this.pen2D;
		var data = pen.arr;
		var redA = 0.;
		var greenA = 0.;
		var blueA = 0.;
		var alphaA = 0.;
		var colorA = 0;
		var redB = 0.;
		var greenB = 0.;
		var blueB = 0.;
		var alphaB = 0.;
		var colorB = 0;
		var redC = 0.;
		var greenC = 0.;
		var blueC = 0.;
		var alphaC = 0.;
		var colorC = 0;
		this.totalTriangles = (data.length - 1) / 9 | 0;
		this.bufferLength = this.totalTriangles * 3;
		this.len = this.totalTriangles * 6 * 3 | 0;
		var j = 0;
		var this1 = new Float32Array(this.len);
		this.arr32 = this1;
		haxe_Log.trace("total triangles " + this.len,{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL.js.hx", lineNumber : 150, className : "cornerContourWebGLTest.CornerContourWebGL", methodName : "rearrageDrawData"});
		var _g = 0;
		var _g1 = this.totalTriangles;
		while(_g < _g1) {
			var i = _g++;
			pen.arr[0] = i;
			colorA = cornerContour_io_Array2DTriGrad.get_colorA(data) | 0;
			alphaA = (colorA >> 24 & 255) / 255;
			redA = (colorA >> 16 & 255) / 255;
			greenA = (colorA >> 8 & 255) / 255;
			blueA = (colorA & 255) / 255;
			colorB = cornerContour_io_Array2DTriGrad.get_colorB(data) | 0;
			alphaB = (colorB >> 24 & 255) / 255;
			redB = (colorB >> 16 & 255) / 255;
			greenB = (colorB >> 8 & 255) / 255;
			blueB = (colorB & 255) / 255;
			colorC = cornerContour_io_Array2DTriGrad.get_colorC(data) | 0;
			alphaC = (colorC >> 24 & 255) / 255;
			redC = (colorC >> 16 & 255) / 255;
			greenC = (colorC >> 8 & 255) / 255;
			blueC = (colorC & 255) / 255;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriGrad.get_ax(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriGrad.get_ay(data) / this.height;
			++j;
			this.arr32[j] = redA;
			++j;
			this.arr32[j] = greenA;
			++j;
			this.arr32[j] = blueA;
			++j;
			this.arr32[j] = alphaA;
			++j;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriGrad.get_bx(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriGrad.get_by(data) / this.height;
			++j;
			this.arr32[j] = redB;
			++j;
			this.arr32[j] = greenB;
			++j;
			this.arr32[j] = blueB;
			++j;
			this.arr32[j] = alphaB;
			++j;
			this.arr32[j] = -(1 - 2 * cornerContour_io_Array2DTriGrad.get_cx(data) / this.width);
			++j;
			this.arr32[j] = 1 - 2 * cornerContour_io_Array2DTriGrad.get_cy(data) / this.height;
			++j;
			this.arr32[j] = redC;
			++j;
			this.arr32[j] = greenC;
			++j;
			this.arr32[j] = blueC;
			++j;
			this.arr32[j] = alphaC;
			++j;
		}
	}
	,drawContours: function() {
		haxe_Log.trace("drawContours",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL.js.hx", lineNumber : 281, className : "cornerContourWebGLTest.CornerContourWebGL", methodName : "drawContours"});
		this.pen2D = new cornerContour_Pen2DGrad(-16776961,-16711936,-16776961);
		this.pen2D.currentColor = -16776961;
		this.pen2D.colorB = -16711936;
		this.pen2D.colorC = -16776961;
		this.turtleTest0(150. + Std.random(200),150. + Std.random(200));
		var tmp = Std.random(16777215);
		this.pen2D.currentColor = -16777216 + tmp;
		var tmp = Std.random(16777215);
		this.pen2D.colorB = -16777216 + tmp;
		this.turtleTest1(150. + Std.random(200),150. + Std.random(200));
		var tmp = Std.random(16777215);
		this.pen2D.currentColor = -16777216 + tmp;
		var tmp = Std.random(16777215);
		this.pen2D.colorB = -16777216 + tmp;
		this.turtleTest2(150. + Std.random(200),150. + Std.random(200));
		var tmp = Std.random(16777215);
		this.pen2D.currentColor = -16777216 + tmp;
		var tmp = Std.random(16777215);
		this.pen2D.colorB = -16777216 + tmp;
		this.turtleTest3(150. + Std.random(200),150. + Std.random(200));
		var tmp = Std.random(16777215);
		this.pen2D.currentColor = -16777216 + tmp;
		var tmp = Std.random(16777215);
		this.pen2D.colorB = -16777216 + tmp;
		this.turtleTest4(150. + Std.random(200),150. + Std.random(200));
		var tmp = Std.random(16777215);
		this.pen2D.currentColor = -16777216 + tmp;
		var tmp = Std.random(16777215);
		this.pen2D.colorB = -16777216 + tmp;
		this.turtleTest5(150. + Std.random(200),150. + Std.random(200));
		var tmp = Std.random(16777215);
		this.pen2D.currentColor = -16777216 + tmp;
		var tmp = Std.random(16777215);
		this.pen2D.colorB = -16777216 + tmp;
		this.turtleTest6(150. + Std.random(200),150. + Std.random(200));
		var tmp = Std.random(16777215);
		this.pen2D.currentColor = -16777216 + tmp;
		var tmp = Std.random(16777215);
		this.pen2D.colorB = -16777216 + tmp;
		this.turtleTest7(150. + Std.random(200),150. + Std.random(200));
	}
	,renderOnce: function() {
		haxe_Log.trace("renderOnce",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL.js.hx", lineNumber : 369, className : "cornerContourWebGLTest.CornerContourWebGL", methodName : "renderOnce"});
		this.mainSheet = new cornerContourWebGLTest_Sheet();
		this.mainSheet.create(this.width,this.height,true);
		this.gl = this.mainSheet.gl;
		var gl = this.gl;
		var width = this.width;
		var height = this.height;
		var r = 0.;
		var g = 0.;
		var b = 0.;
		var a = 1.;
		if(a == null) {
			a = 0.;
		}
		if(b == null) {
			b = 0.;
		}
		if(g == null) {
			g = 0.;
		}
		if(r == null) {
			r = 0.;
		}
		gl.clearColor(r,g,b,a);
		gl.enable(2929);
		gl.clear(16384);
		gl.viewport(0,0,width,height);
		gl.enable(3042);
		gl.blendFunc(1,771);
		gl.enable(2929);
		var gl = this.gl;
		var program = gl.createProgram();
		var shader = gl.createShader(35633);
		gl.shaderSource(shader,"attribute vec2 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, .0, 1.0);" + " vcol = vertexColor;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		var shader = gl.createShader(35632);
		gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + "vec4 color = vec4(vcol.rgb, 1. );" + "color *= vcol.a; " + "gl_FragColor = color;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		gl.linkProgram(program);
		var tmp;
		if(!gl.getProgramParameter(program,35714)) {
			throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
		} else {
			gl.validateProgram(program);
			if(!gl.getProgramParameter(program,35715)) {
				throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
			} else {
				gl.useProgram(program);
				tmp = program;
			}
		}
		this.programColor = tmp;
		this.gl.bindBuffer(34962,null);
		this.gl.useProgram(this.programColor);
		var gl = this.gl;
		var program = this.programColor;
		var data = this.arr32;
		var xyName = this.vertexPosition;
		var rgbaName = this.vertexColor;
		var isDynamic = true;
		if(isDynamic == null) {
			isDynamic = false;
		}
		var isDynamic1 = isDynamic;
		if(isDynamic1 == null) {
			isDynamic1 = false;
		}
		var buf = gl.createBuffer();
		var staticDraw = 35044;
		var dynamicDraw = 35048;
		var arrayBuffer = 34962;
		gl.bindBuffer(arrayBuffer,buf);
		if(isDynamic1) {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,dynamicDraw);
		} else {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,staticDraw);
		}
		var vbo = buf;
		var inp = gl.getAttribLocation(program,xyName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 6 * elementBytes;
		var offBytes = 0 * elementBytes;
		gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,rgbaName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 6 * elementBytes;
		var offBytes = 2 * elementBytes;
		gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		this.bufColor = vbo;
		this.gl.bindBuffer(34962,this.bufColor);
		this.gl.useProgram(this.programColor);
		this.gl.drawArrays(4,0,this.bufferLength);
	}
	,turtleTest0: function(x,y) {
		var sketcher = new cornerContour_SketcherGrad(this.pen2D,4,this.styleEnd);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(30);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(30);
		} else {
			_this.width = 30;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(60);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(60);
		} else {
			var nx = _this1.x + 60 * Math.cos(_this1.rotation);
			var ny = _this1.y + 60 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 60;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(45);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(45);
		} else {
			_this.rotation += 45 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(60);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(60);
		} else {
			var nx = _this1.x + 60 * Math.cos(_this1.rotation);
			var ny = _this1.y + 60 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 60;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(45);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(45);
		} else {
			_this.rotation += 45 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(70);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(70);
		} else {
			var nx = _this1.x + 70 * Math.cos(_this1.rotation);
			var ny = _this1.y + 70 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 70;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("ARC");
			_this.historyParameters.push(50);
			_this.historyParameters.push(120);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("ARC");
			_this.turtleParameters.push(50);
			_this.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this.x;
			var oy = _this.y;
			var arr = [];
			arr.push(_this.x);
			arr.push(_this.y);
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this.rotation += rotate;
				var wasHistoryOn = _this.turtleHistoryOn;
				_this.turtleHistoryOn = false;
				if(_this.turtleHistoryOn) {
					_this.historyAdd("FORWARD");
					_this.historyParameters.push(baseLength);
				}
				if(_this.repeatCommands) {
					_this.turtleCommands.push("FORWARD");
					_this.turtleParameters.push(baseLength);
				} else {
					var nx = _this.x + baseLength * Math.cos(_this.rotation);
					var ny = _this.y + baseLength * Math.sin(_this.rotation);
					if(_this.penIsDown) {
						_this.lastDistance = baseLength;
						_this.lineTo(nx,ny);
					} else {
						if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
							_this.contour.end(_this.width);
						}
						_this.x = nx;
						_this.y = ny;
						var l = _this.points.length;
						_this.points[l] = [];
						_this.points[l][0] = nx;
						_this.points[l][1] = ny;
						_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
						_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
						_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this.dim[_this.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this.contour.reset();
					}
				}
				_this.turtleHistoryOn = wasHistoryOn;
				if(_this.fill) {
					arr.push(_this.x);
					arr.push(_this.y);
				}
			}
			if(_this.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i < l) {
					if(i > 2) {
						_this.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var p_x = sketcher.x;
		var p_y = sketcher.y;
		var x_ = p_x;
		var y_ = p_y;
		if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
			sketcher.contour.end(sketcher.width);
		}
		sketcher.x = x_;
		sketcher.y = y_;
		var l = sketcher.points.length;
		sketcher.points[l] = [];
		sketcher.points[l][0] = x_;
		sketcher.points[l][1] = y_;
		sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
		sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
		sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = sketcher.dim[sketcher.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		sketcher.contour.reset();
	}
	,turtleTest1: function(x,y) {
		var sketcher = new cornerContour_SketcherGrad(this.pen2D,4,this.styleEnd);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(30);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(30);
		} else {
			_this.width = 30;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("RIGHT");
			_this1.historyParameters.push(90);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("RIGHT");
			_this1.turtleParameters.push(90);
		} else {
			_this1.rotation += 90 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(60);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(60);
		} else {
			var nx = _this.x + 60 * Math.cos(_this.rotation);
			var ny = _this.y + 60 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 60;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(45);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(45);
		} else {
			_this1.rotation -= 45 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(70);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(70);
		} else {
			var nx = _this.x + 70 * Math.cos(_this.rotation);
			var ny = _this.y + 70 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 70;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARC");
			_this1.historyParameters.push(50);
			_this1.historyParameters.push(120);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARC");
			_this1.turtleParameters.push(50);
			_this1.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this1.x;
			var oy = _this1.y;
			var arr = [];
			arr.push(_this1.x);
			arr.push(_this1.y);
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this1.rotation += rotate;
				var wasHistoryOn = _this1.turtleHistoryOn;
				_this1.turtleHistoryOn = false;
				if(_this1.turtleHistoryOn) {
					_this1.historyAdd("FORWARD");
					_this1.historyParameters.push(baseLength);
				}
				if(_this1.repeatCommands) {
					_this1.turtleCommands.push("FORWARD");
					_this1.turtleParameters.push(baseLength);
				} else {
					var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
					var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
					if(_this1.penIsDown) {
						_this1.lastDistance = baseLength;
						_this1.lineTo(nx,ny);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = nx;
						_this1.y = ny;
						var l = _this1.points.length;
						_this1.points[l] = [];
						_this1.points[l][0] = nx;
						_this1.points[l][1] = ny;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this1.dim[_this1.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this1.contour.reset();
					}
				}
				_this1.turtleHistoryOn = wasHistoryOn;
				if(_this1.fill) {
					arr.push(_this1.x);
					arr.push(_this1.y);
				}
			}
			if(_this1.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i < l) {
					if(i > 2) {
						_this1.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("LEFT");
			_this.historyParameters.push(50);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("LEFT");
			_this.turtleParameters.push(50);
		} else {
			_this.rotation -= 50 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(70);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(70);
		} else {
			var nx = _this1.x + 70 * Math.cos(_this1.rotation);
			var ny = _this1.y + 70 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 70;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(10);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(10);
		} else {
			var nx = _this.x + 10 * Math.cos(_this.rotation);
			var ny = _this.y + 10 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 10;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var p_x = sketcher.x;
		var p_y = sketcher.y;
		var x_ = p_x + 1;
		var y_ = p_y + 1;
		if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
			sketcher.contour.end(sketcher.width);
		}
		sketcher.x = x_;
		sketcher.y = y_;
		var l = sketcher.points.length;
		sketcher.points[l] = [];
		sketcher.points[l][0] = x_;
		sketcher.points[l][1] = y_;
		sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
		sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
		sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = sketcher.dim[sketcher.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		sketcher.contour.reset();
	}
	,turtleTest2: function(x,y) {
		var sketcher = new cornerContour_SketcherGrad(this.pen2D,4,this.styleEnd);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(30);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(30);
		} else {
			_this.width = 30;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(90);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(90);
		} else {
			_this1.rotation -= 90 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(60);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(60);
		} else {
			var nx = _this.x + 60 * Math.cos(_this.rotation);
			var ny = _this.y + 60 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 60;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("RIGHT");
			_this1.historyParameters.push(45);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("RIGHT");
			_this1.turtleParameters.push(45);
		} else {
			_this1.rotation += 45 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(70);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(70);
		} else {
			var nx = _this.x + 70 * Math.cos(_this.rotation);
			var ny = _this.y + 70 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 70;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARC");
			_this1.historyParameters.push(50);
			_this1.historyParameters.push(120);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARC");
			_this1.turtleParameters.push(50);
			_this1.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this1.x;
			var oy = _this1.y;
			var arr = [];
			arr.push(_this1.x);
			arr.push(_this1.y);
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this1.rotation += rotate;
				var wasHistoryOn = _this1.turtleHistoryOn;
				_this1.turtleHistoryOn = false;
				if(_this1.turtleHistoryOn) {
					_this1.historyAdd("FORWARD");
					_this1.historyParameters.push(baseLength);
				}
				if(_this1.repeatCommands) {
					_this1.turtleCommands.push("FORWARD");
					_this1.turtleParameters.push(baseLength);
				} else {
					var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
					var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
					if(_this1.penIsDown) {
						_this1.lastDistance = baseLength;
						_this1.lineTo(nx,ny);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = nx;
						_this1.y = ny;
						var l = _this1.points.length;
						_this1.points[l] = [];
						_this1.points[l][0] = nx;
						_this1.points[l][1] = ny;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this1.dim[_this1.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this1.contour.reset();
					}
				}
				_this1.turtleHistoryOn = wasHistoryOn;
				if(_this1.fill) {
					arr.push(_this1.x);
					arr.push(_this1.y);
				}
			}
			if(_this1.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i < l) {
					if(i > 2) {
						_this1.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(50);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(50);
		} else {
			_this.rotation += 50 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(70);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(70);
		} else {
			var nx = _this1.x + 70 * Math.cos(_this1.rotation);
			var ny = _this1.y + 70 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 70;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var p_x = sketcher.x;
		var p_y = sketcher.y;
		var x_ = p_x;
		var y_ = p_y;
		if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
			sketcher.contour.end(sketcher.width);
		}
		sketcher.x = x_;
		sketcher.y = y_;
		var l = sketcher.points.length;
		sketcher.points[l] = [];
		sketcher.points[l][0] = x_;
		sketcher.points[l][1] = y_;
		sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
		sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
		sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = sketcher.dim[sketcher.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		sketcher.contour.reset();
	}
	,turtleTest3: function(x,y) {
		var sketcher = new cornerContour_SketcherGrad(this.pen2D,4,this.styleEnd);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(30);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(30);
		} else {
			_this.width = 30;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(90);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(90);
		} else {
			_this1.rotation -= 90 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(60);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(60);
		} else {
			var nx = _this.x + 60 * Math.cos(_this.rotation);
			var ny = _this.y + 60 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 60;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("RIGHT");
			_this1.historyParameters.push(45);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("RIGHT");
			_this1.turtleParameters.push(45);
		} else {
			_this1.rotation += 45 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(70);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(70);
		} else {
			var nx = _this.x + 70 * Math.cos(_this.rotation);
			var ny = _this.y + 70 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 70;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARC");
			_this1.historyParameters.push(50);
			_this1.historyParameters.push(120);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARC");
			_this1.turtleParameters.push(50);
			_this1.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this1.x;
			var oy = _this1.y;
			var arr = [];
			arr.push(_this1.x);
			arr.push(_this1.y);
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this1.rotation += rotate;
				var wasHistoryOn = _this1.turtleHistoryOn;
				_this1.turtleHistoryOn = false;
				if(_this1.turtleHistoryOn) {
					_this1.historyAdd("FORWARD");
					_this1.historyParameters.push(baseLength);
				}
				if(_this1.repeatCommands) {
					_this1.turtleCommands.push("FORWARD");
					_this1.turtleParameters.push(baseLength);
				} else {
					var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
					var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
					if(_this1.penIsDown) {
						_this1.lastDistance = baseLength;
						_this1.lineTo(nx,ny);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = nx;
						_this1.y = ny;
						var l = _this1.points.length;
						_this1.points[l] = [];
						_this1.points[l][0] = nx;
						_this1.points[l][1] = ny;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this1.dim[_this1.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this1.contour.reset();
					}
				}
				_this1.turtleHistoryOn = wasHistoryOn;
				if(_this1.fill) {
					arr.push(_this1.x);
					arr.push(_this1.y);
				}
			}
			if(_this1.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i < l) {
					if(i > 2) {
						_this1.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("LEFT");
			_this.historyParameters.push(50);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("LEFT");
			_this.turtleParameters.push(50);
		} else {
			_this.rotation -= 50 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(70);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(70);
		} else {
			var nx = _this1.x + 70 * Math.cos(_this1.rotation);
			var ny = _this1.y + 70 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 70;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var p_x = sketcher.x;
		var p_y = sketcher.y;
		var x_ = p_x;
		var y_ = p_y;
		if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
			sketcher.contour.end(sketcher.width);
		}
		sketcher.x = x_;
		sketcher.y = y_;
		var l = sketcher.points.length;
		sketcher.points[l] = [];
		sketcher.points[l][0] = x_;
		sketcher.points[l][1] = y_;
		sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
		sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
		sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = sketcher.dim[sketcher.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		sketcher.contour.reset();
	}
	,turtleTest4: function(x,y) {
		var sketcher = new cornerContour_SketcherGrad(this.pen2D,4,this.styleEnd);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(30);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(30);
		} else {
			_this.width = 30;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(90);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(90);
		} else {
			_this1.rotation -= 90 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(60);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(60);
		} else {
			var nx = _this.x + 60 * Math.cos(_this.rotation);
			var ny = _this.y + 60 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 60;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(45);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(45);
		} else {
			_this1.rotation -= 45 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(70);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(70);
		} else {
			var nx = _this.x + 70 * Math.cos(_this.rotation);
			var ny = _this.y + 70 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 70;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARC");
			_this1.historyParameters.push(50);
			_this1.historyParameters.push(120);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARC");
			_this1.turtleParameters.push(50);
			_this1.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this1.x;
			var oy = _this1.y;
			var arr = [];
			arr.push(_this1.x);
			arr.push(_this1.y);
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this1.rotation += rotate;
				var wasHistoryOn = _this1.turtleHistoryOn;
				_this1.turtleHistoryOn = false;
				if(_this1.turtleHistoryOn) {
					_this1.historyAdd("FORWARD");
					_this1.historyParameters.push(baseLength);
				}
				if(_this1.repeatCommands) {
					_this1.turtleCommands.push("FORWARD");
					_this1.turtleParameters.push(baseLength);
				} else {
					var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
					var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
					if(_this1.penIsDown) {
						_this1.lastDistance = baseLength;
						_this1.lineTo(nx,ny);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = nx;
						_this1.y = ny;
						var l = _this1.points.length;
						_this1.points[l] = [];
						_this1.points[l][0] = nx;
						_this1.points[l][1] = ny;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this1.dim[_this1.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this1.contour.reset();
					}
				}
				_this1.turtleHistoryOn = wasHistoryOn;
				if(_this1.fill) {
					arr.push(_this1.x);
					arr.push(_this1.y);
				}
			}
			if(_this1.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i < l) {
					if(i > 2) {
						_this1.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("LEFT");
			_this.historyParameters.push(50);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("LEFT");
			_this.turtleParameters.push(50);
		} else {
			_this.rotation -= 50 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(70);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(70);
		} else {
			var nx = _this1.x + 70 * Math.cos(_this1.rotation);
			var ny = _this1.y + 70 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 70;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var p_x = sketcher.x;
		var p_y = sketcher.y;
		var x_ = p_x;
		var y_ = p_y;
		if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
			sketcher.contour.end(sketcher.width);
		}
		sketcher.x = x_;
		sketcher.y = y_;
		var l = sketcher.points.length;
		sketcher.points[l] = [];
		sketcher.points[l][0] = x_;
		sketcher.points[l][1] = y_;
		sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
		sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
		sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = sketcher.dim[sketcher.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		sketcher.contour.reset();
	}
	,turtleTest5: function(x,y) {
		var sketcher = new cornerContour_SketcherGrad(this.pen2D,4,this.styleEnd);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(30);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(30);
		} else {
			_this.width = 30;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(180);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(180);
		} else {
			_this1.rotation -= 180 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(60);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(60);
		} else {
			var nx = _this.x + 60 * Math.cos(_this.rotation);
			var ny = _this.y + 60 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 60;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(45);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(45);
		} else {
			_this1.rotation -= 45 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(70);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(70);
		} else {
			var nx = _this.x + 70 * Math.cos(_this.rotation);
			var ny = _this.y + 70 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 70;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARC");
			_this1.historyParameters.push(50);
			_this1.historyParameters.push(120);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARC");
			_this1.turtleParameters.push(50);
			_this1.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this1.x;
			var oy = _this1.y;
			var arr = [];
			arr.push(_this1.x);
			arr.push(_this1.y);
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this1.rotation += rotate;
				var wasHistoryOn = _this1.turtleHistoryOn;
				_this1.turtleHistoryOn = false;
				if(_this1.turtleHistoryOn) {
					_this1.historyAdd("FORWARD");
					_this1.historyParameters.push(baseLength);
				}
				if(_this1.repeatCommands) {
					_this1.turtleCommands.push("FORWARD");
					_this1.turtleParameters.push(baseLength);
				} else {
					var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
					var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
					if(_this1.penIsDown) {
						_this1.lastDistance = baseLength;
						_this1.lineTo(nx,ny);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = nx;
						_this1.y = ny;
						var l = _this1.points.length;
						_this1.points[l] = [];
						_this1.points[l][0] = nx;
						_this1.points[l][1] = ny;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this1.dim[_this1.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this1.contour.reset();
					}
				}
				_this1.turtleHistoryOn = wasHistoryOn;
				if(_this1.fill) {
					arr.push(_this1.x);
					arr.push(_this1.y);
				}
			}
			if(_this1.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i < l) {
					if(i > 2) {
						_this1.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("LEFT");
			_this.historyParameters.push(50);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("LEFT");
			_this.turtleParameters.push(50);
		} else {
			_this.rotation -= 50 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(70);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(70);
		} else {
			var nx = _this1.x + 70 * Math.cos(_this1.rotation);
			var ny = _this1.y + 70 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 70;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var p_x = sketcher.x;
		var p_y = sketcher.y;
		var x_ = p_x;
		var y_ = p_y;
		if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
			sketcher.contour.end(sketcher.width);
		}
		sketcher.x = x_;
		sketcher.y = y_;
		var l = sketcher.points.length;
		sketcher.points[l] = [];
		sketcher.points[l][0] = x_;
		sketcher.points[l][1] = y_;
		sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
		sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
		sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = sketcher.dim[sketcher.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		sketcher.contour.reset();
	}
	,turtleTest6: function(x,y) {
		var sketcher = new cornerContour_SketcherGrad(this.pen2D,4,this.styleEnd);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(30);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(30);
		} else {
			_this.width = 30;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(180);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(180);
		} else {
			_this1.rotation -= 180 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(60);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(60);
		} else {
			var nx = _this.x + 60 * Math.cos(_this.rotation);
			var ny = _this.y + 60 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 60;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("RIGHT");
			_this1.historyParameters.push(45);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("RIGHT");
			_this1.turtleParameters.push(45);
		} else {
			_this1.rotation += 45 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(70);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(70);
		} else {
			var nx = _this.x + 70 * Math.cos(_this.rotation);
			var ny = _this.y + 70 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 70;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARC");
			_this1.historyParameters.push(50);
			_this1.historyParameters.push(120);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARC");
			_this1.turtleParameters.push(50);
			_this1.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this1.x;
			var oy = _this1.y;
			var arr = [];
			arr.push(_this1.x);
			arr.push(_this1.y);
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this1.rotation += rotate;
				var wasHistoryOn = _this1.turtleHistoryOn;
				_this1.turtleHistoryOn = false;
				if(_this1.turtleHistoryOn) {
					_this1.historyAdd("FORWARD");
					_this1.historyParameters.push(baseLength);
				}
				if(_this1.repeatCommands) {
					_this1.turtleCommands.push("FORWARD");
					_this1.turtleParameters.push(baseLength);
				} else {
					var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
					var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
					if(_this1.penIsDown) {
						_this1.lastDistance = baseLength;
						_this1.lineTo(nx,ny);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = nx;
						_this1.y = ny;
						var l = _this1.points.length;
						_this1.points[l] = [];
						_this1.points[l][0] = nx;
						_this1.points[l][1] = ny;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this1.dim[_this1.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this1.contour.reset();
					}
				}
				_this1.turtleHistoryOn = wasHistoryOn;
				if(_this1.fill) {
					arr.push(_this1.x);
					arr.push(_this1.y);
				}
			}
			if(_this1.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i < l) {
					if(i > 2) {
						_this1.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("LEFT");
			_this.historyParameters.push(50);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("LEFT");
			_this.turtleParameters.push(50);
		} else {
			_this.rotation -= 50 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(70);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(70);
		} else {
			var nx = _this1.x + 70 * Math.cos(_this1.rotation);
			var ny = _this1.y + 70 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 70;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var p_x = sketcher.x;
		var p_y = sketcher.y;
		var x_ = p_x;
		var y_ = p_y;
		if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
			sketcher.contour.end(sketcher.width);
		}
		sketcher.x = x_;
		sketcher.y = y_;
		var l = sketcher.points.length;
		sketcher.points[l] = [];
		sketcher.points[l][0] = x_;
		sketcher.points[l][1] = y_;
		sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
		sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
		sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = sketcher.dim[sketcher.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		sketcher.contour.reset();
	}
	,turtleTest7: function(x,y) {
		var sketcher = new cornerContour_SketcherGrad(this.pen2D,4,this.styleEnd);
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(30);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(30);
		} else {
			_this.width = 30;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("LEFT");
			_this1.historyParameters.push(180);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("LEFT");
			_this1.turtleParameters.push(180);
		} else {
			_this1.rotation -= 180 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(60);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(60);
		} else {
			var nx = _this.x + 60 * Math.cos(_this.rotation);
			var ny = _this.y + 60 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 60;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("RIGHT");
			_this1.historyParameters.push(45);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("RIGHT");
			_this1.turtleParameters.push(45);
		} else {
			_this1.rotation += 45 * Math.PI / 180;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("FORWARD");
			_this.historyParameters.push(70);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("FORWARD");
			_this.turtleParameters.push(70);
		} else {
			var nx = _this.x + 70 * Math.cos(_this.rotation);
			var ny = _this.y + 70 * Math.sin(_this.rotation);
			if(_this.penIsDown) {
				_this.lastDistance = 70;
				_this.lineTo(nx,ny);
			} else {
				if(_this.endLine == 2 || _this.endLine == 3 || _this.endLine == 4 || _this.endLine == 7 || _this.endLine == 8 || _this.endLine == 10 || _this.endLine == 11 || _this.endLine == 5) {
					_this.contour.end(_this.width);
				}
				_this.x = nx;
				_this.y = ny;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = nx;
				_this.points[l][1] = ny;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this.contour.reset();
			}
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARC");
			_this1.historyParameters.push(50);
			_this1.historyParameters.push(120);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARC");
			_this1.turtleParameters.push(50);
			_this1.turtleParameters.push(120);
		} else {
			var beta = 120 * Math.PI / 180 / 24;
			var alpha = (Math.PI - beta) / 2;
			var rotate = -(Math.PI / 2 - alpha);
			var baseLength = 25. * Math.sin(beta / 2);
			var ox = _this1.x;
			var oy = _this1.y;
			var arr = [];
			arr.push(_this1.x);
			arr.push(_this1.y);
			var _g = 0;
			while(_g < 48) {
				var i = _g++;
				_this1.rotation += rotate;
				var wasHistoryOn = _this1.turtleHistoryOn;
				_this1.turtleHistoryOn = false;
				if(_this1.turtleHistoryOn) {
					_this1.historyAdd("FORWARD");
					_this1.historyParameters.push(baseLength);
				}
				if(_this1.repeatCommands) {
					_this1.turtleCommands.push("FORWARD");
					_this1.turtleParameters.push(baseLength);
				} else {
					var nx = _this1.x + baseLength * Math.cos(_this1.rotation);
					var ny = _this1.y + baseLength * Math.sin(_this1.rotation);
					if(_this1.penIsDown) {
						_this1.lastDistance = baseLength;
						_this1.lineTo(nx,ny);
					} else {
						if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
							_this1.contour.end(_this1.width);
						}
						_this1.x = nx;
						_this1.y = ny;
						var l = _this1.points.length;
						_this1.points[l] = [];
						_this1.points[l][0] = nx;
						_this1.points[l][1] = ny;
						_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
						_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
						_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = _this1.dim[_this1.dim.length - 1];
						if(nx < d.minX) {
							d.minX = nx;
						}
						if(nx > d.maxX) {
							d.maxX = nx;
						}
						if(ny < d.minY) {
							d.minY = ny;
						}
						if(ny > d.maxY) {
							d.maxY = ny;
						}
						_this1.contour.reset();
					}
				}
				_this1.turtleHistoryOn = wasHistoryOn;
				if(_this1.fill) {
					arr.push(_this1.x);
					arr.push(_this1.y);
				}
			}
			if(_this1.fill) {
				var cx = (ox + arr[arr.length - 2]) / 2;
				var cy = (oy + arr[arr.length - 1]) / 2;
				var l = arr.length;
				var i = 2;
				var lx = 0.;
				var ly = 0.;
				_this1.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
				while(i < l) {
					if(i > 2) {
						_this1.pen.triangle2DFill(lx,ly,arr[i],arr[i + 1],cx,cy);
					}
					lx = arr[i];
					ly = arr[i + 1];
					i += 2;
				}
			}
			arr.length = 0;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(50);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(50);
		} else {
			_this.rotation += 50 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FORWARD");
			_this1.historyParameters.push(70);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FORWARD");
			_this1.turtleParameters.push(70);
		} else {
			var nx = _this1.x + 70 * Math.cos(_this1.rotation);
			var ny = _this1.y + 70 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				_this1.lastDistance = 70;
				_this1.lineTo(nx,ny);
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3 || _this1.endLine == 4 || _this1.endLine == 7 || _this1.endLine == 8 || _this1.endLine == 10 || _this1.endLine == 11 || _this1.endLine == 5) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var p_x = sketcher.x;
		var p_y = sketcher.y;
		var x_ = p_x;
		var y_ = p_y;
		if(sketcher.endLine == 2 || sketcher.endLine == 3 || sketcher.endLine == 4 || sketcher.endLine == 7 || sketcher.endLine == 8 || sketcher.endLine == 10 || sketcher.endLine == 11 || sketcher.endLine == 5) {
			sketcher.contour.end(sketcher.width);
		}
		sketcher.x = x_;
		sketcher.y = y_;
		var l = sketcher.points.length;
		sketcher.points[l] = [];
		sketcher.points[l][0] = x_;
		sketcher.points[l][1] = y_;
		sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
		sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
		sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = sketcher.dim[sketcher.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		sketcher.contour.reset();
	}
};
function cornerContourWebGLTest_CornerContourWebGL_main() {
	new cornerContourWebGLTest_CornerContourWebGL();
}
var cornerContourWebGLTest_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
	window.onerror = $bind(this,this.myError);
};
cornerContourWebGLTest_DivertTrace.__name__ = true;
cornerContourWebGLTest_DivertTrace.prototype = {
	myError: function(msg,url,lineNo,columnNo,errorObj) {
		var arr = url.split("/");
		var file = arr[arr.length - 2] + " " + arr[arr.length - 1];
		var str = this.textStyle0;
		str += "ERROR: " + file + " ( " + (lineNo == null ? "null" : "" + lineNo) + ": " + (columnNo == null ? "null" : "" + columnNo) + " )";
		str += "</span>";
		str += "<br> - ";
		str += this.textStyle1;
		str += Std.string(msg);
		str += "</span>";
		str += "<br>";
		this.traceString += str;
		this.traceDiv.innerHTML = this.traceString;
		return false;
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var cornerContourWebGLTest_Sheet = function() {
};
cornerContourWebGLTest_Sheet.__name__ = true;
cornerContourWebGLTest_Sheet.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasGL = window.document.createElement("canvas");
		this.canvasGL.width = this.width;
		this.canvasGL.height = this.height;
		var body = window.document.body;
		body.style.overflow = "hidden";
		body.style.position = "fixed";
		this.pixelRatio = window.devicePixelRatio;
		if(this.pixelRatio == null) {
			this.pixelRatio = 1.;
		}
		var bodyEL = window.document.body;
		var style = bodyEL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		this.domGL = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvasGL);
		}
		this.canvas2D = window.document.createElement("canvas");
		this.canvas2D.width = this.width;
		this.canvas2D.height = this.height;
		this.domGL2D = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvas2D);
		}
		this.gl = this.canvasGL.getContext("webgl",{ premultipliedAlpha : false});
		this.cx = this.canvas2D.getContext("2d");
	}
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__:true,__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL_OLD: {_hx_name:"SMALL_OLD",_hx_index:4,__enum__:"fracs.DifferencePreference",toString:$estr}
};
fracs_DifferencePreference.__constructs__ = [fracs_DifferencePreference.CLOCKWISE,fracs_DifferencePreference.ANTICLOCKWISE,fracs_DifferencePreference.SMALL,fracs_DifferencePreference.LARGE,fracs_DifferencePreference.SMALL_OLD];
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:true,__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Left",$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Right",$_.__params__ = ["v"],$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
cornerContourWebGLTest_CornerContourWebGL_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
